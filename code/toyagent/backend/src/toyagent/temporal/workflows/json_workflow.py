"""JsonWorkflow - executes workflow specs generated by LLM."""

import asyncio
import logging
import re
from dataclasses import dataclass
from datetime import timedelta
from typing import Any

from temporalio import workflow
from temporalio.common import RetryPolicy

with workflow.unsafe.imports_passed_through():
    from toyagent.temporal.activities import send_email, call_llm, search_web

logger = logging.getLogger(__name__)

# Map tool names to activity functions
TOOL_ACTIVITIES = {
    "send_email": send_email,
    "call_llm": call_llm,
    "search_web": search_web,
}

# Default retry policy for activities
DEFAULT_RETRY_POLICY = RetryPolicy(
    initial_interval=timedelta(seconds=1),
    backoff_coefficient=2.0,
    maximum_interval=timedelta(seconds=30),
    maximum_attempts=3,
)


@dataclass
class JsonWorkflowInput:
    """Input for JsonWorkflow."""

    workflow_id: str
    chat_id: str
    spec: dict[str, Any]  # WorkflowSpec as dict
    context: dict[str, Any] | None = None


@workflow.defn
class JsonWorkflow:
    """
    Workflow that executes a JSON workflow spec.

    The spec follows this format:
    {
        "name": "workflow_name",
        "version": "1.0",
        "steps": [
            {
                "id": "step_1",
                "type": "tool",
                "title": "Step description",
                "uses": "tool_name",
                "input": {"param": "value"},
                "output_key": "result_1"
            },
            ...
        ]
    }
    """

    def __init__(self):
        self._results: dict[str, Any] = {}
        self._step_statuses: dict[str, str] = {}
        self._current_step: str | None = None

    @workflow.run
    async def run(self, input: JsonWorkflowInput) -> dict[str, Any]:
        """Execute the workflow spec."""
        spec = input.spec
        context = input.context or {}

        workflow.logger.info(f"Starting workflow: {spec.get('name', 'unknown')}")

        steps = spec.get("steps", [])
        if not steps:
            return {
                "success": False,
                "error": "No steps in workflow spec",
                "results": {},
            }

        # Initialize step statuses
        for step in steps:
            self._step_statuses[step["id"]] = "pending"

        # Store initial context
        self._results["context"] = context

        # Execute steps
        for step in steps:
            step_id = step["id"]
            step_type = step.get("type", "tool")
            self._current_step = step_id
            self._step_statuses[step_id] = "running"

            workflow.logger.info(f"Executing step: {step_id} ({step_type})")

            try:
                if step_type == "tool":
                    result = await self._execute_tool_step(step)
                elif step_type == "llm":
                    result = await self._execute_llm_step(step)
                elif step_type == "condition":
                    result = await self._execute_condition_step(step)
                elif step_type == "parallel":
                    result = await self._execute_parallel_step(step)
                else:
                    result = {"success": False, "error": f"Unknown step type: {step_type}"}

                # Store result if output_key is specified
                output_key = step.get("output_key")
                if output_key:
                    self._results[output_key] = result

                if not result.get("success", True):
                    self._step_statuses[step_id] = "failed"
                    workflow.logger.error(f"Step {step_id} failed: {result.get('error')}")
                    return {
                        "success": False,
                        "error": f"Step {step_id} failed: {result.get('error')}",
                        "results": self._results,
                        "step_statuses": self._step_statuses,
                    }

                self._step_statuses[step_id] = "completed"

            except Exception as e:
                self._step_statuses[step_id] = "failed"
                workflow.logger.exception(f"Step {step_id} raised exception: {e}")
                return {
                    "success": False,
                    "error": f"Step {step_id} raised exception: {str(e)}",
                    "results": self._results,
                    "step_statuses": self._step_statuses,
                }

        workflow.logger.info("Workflow completed successfully")
        return {
            "success": True,
            "results": self._results,
            "step_statuses": self._step_statuses,
        }

    def _resolve_placeholders(self, value: Any) -> Any:
        """Resolve {{placeholder}} references in values."""
        if isinstance(value, str):
            # Find all {{key}} patterns
            pattern = r"\{\{(\w+(?:\.\w+)*)\}\}"
            matches = re.findall(pattern, value)

            for match in matches:
                # Resolve nested keys like "result_1.reply"
                keys = match.split(".")
                resolved = self._results
                for key in keys:
                    if isinstance(resolved, dict):
                        resolved = resolved.get(key)
                    else:
                        resolved = None
                        break

                if resolved is not None:
                    # If the entire value is just the placeholder, return the resolved value directly
                    if value == f"{{{{{match}}}}}":
                        return resolved
                    # Otherwise, replace the placeholder in the string
                    value = value.replace(f"{{{{{match}}}}}", str(resolved))

            return value
        elif isinstance(value, dict):
            return {k: self._resolve_placeholders(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [self._resolve_placeholders(item) for item in value]
        return value

    async def _execute_tool_step(self, step: dict[str, Any]) -> dict[str, Any]:
        """Execute a tool step."""
        tool_name = step.get("uses", "")
        params = self._resolve_placeholders(step.get("input", {}))

        activity_func = TOOL_ACTIVITIES.get(tool_name)
        if not activity_func:
            return {"success": False, "error": f"Unknown tool: {tool_name}"}

        result = await workflow.execute_activity(
            activity_func,
            params,
            start_to_close_timeout=timedelta(minutes=5),
            retry_policy=DEFAULT_RETRY_POLICY,
        )
        return result

    async def _execute_llm_step(self, step: dict[str, Any]) -> dict[str, Any]:
        """Execute an LLM step."""
        params = self._resolve_placeholders(step.get("input", {}))

        result = await workflow.execute_activity(
            call_llm,
            params,
            start_to_close_timeout=timedelta(minutes=2),
            retry_policy=DEFAULT_RETRY_POLICY,
        )
        return result

    async def _execute_condition_step(self, step: dict[str, Any]) -> dict[str, Any]:
        """Execute a condition step (placeholder)."""
        # For now, just return success
        # Full implementation would evaluate the condition and branch
        workflow.logger.info(f"Condition step {step['id']}: placeholder implementation")
        return {"success": True, "message": "Condition evaluation not yet implemented"}

    async def _execute_parallel_step(self, step: dict[str, Any]) -> dict[str, Any]:
        """Execute multiple steps in parallel."""
        parallel_steps = step.get("input", {}).get("steps", [])
        if not parallel_steps:
            return {"success": True, "results": []}

        # Execute all steps concurrently
        tasks = []
        for sub_step in parallel_steps:
            step_type = sub_step.get("type", "tool")
            if step_type == "tool":
                tasks.append(self._execute_tool_step(sub_step))
            elif step_type == "llm":
                tasks.append(self._execute_llm_step(sub_step))

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Check for failures
        processed_results = []
        all_success = True
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                processed_results.append({"success": False, "error": str(result)})
                all_success = False
            else:
                processed_results.append(result)
                if not result.get("success", True):
                    all_success = False

        return {
            "success": all_success,
            "results": processed_results,
        }

    @workflow.query
    def get_status(self) -> dict[str, Any]:
        """Query current workflow status."""
        return {
            "current_step": self._current_step,
            "step_statuses": self._step_statuses,
            "results": self._results,
        }
